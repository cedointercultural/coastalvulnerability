#' Scale variable
#'
#' @param datatable
#' @param sspscenario
#'
#' @return num.scale data with scaled total
#' @export
#'
#' @examples scaled.exp <- scale_var(this.data)
scale_var_state <- function(this.data, cost.data.comms, single.mun.coms, indicator.name){

  var <- dplyr::sym(paste0("tot_", indicator.name))

  # cost.data.vals <- loc.data %>%
  #   replace(is.na(.), 0) %>%
  #   mutate(!!var := rowSums(dplyr::across(1:max.col), na.rm=TRUE))

  ent.data <- this.data %>%
    dplyr::left_join(cost.data.comms, by =c("CVE_MUN", "CVE_LOC"))

  ent.cve <- unique(ent.data$CVE_ENT)

  list.ent <- list()

  for(eachstate in 1:length(ent.cve)){

    this.ent.no <- ent.cve[eachstate]
    print(this.ent.no)

    this.ent.data <- ent.data %>%
      keep_when(CVE_ENT==this.ent.no)

    id.cols <- this.ent.data %>%
      distinct(indicator, direction, indicator_category)

    ent.loc.data <- this.ent.data %>%
      select(CVE_MUN, CVE_LOC, indicator, value) %>%
      tidyr::pivot_wider(id_cols = c(CVE_MUN, CVE_LOC), names_from = indicator, values_from = value)

    max.col <- ncol(ent.loc.data)

    list.cols <- list()

   for(eachcol in 1:max.col){

      print(eachcol)
      this.col <- ent.loc.data[,eachcol]

      scaled.this.col <- this.col %>%
        dplyr::mutate_if(is.numeric,~ scales::rescale(., to = c(0, 1)))

      this.col.nom <- colnames(scaled.this.col)

      if(!this.col.nom %in% c("CVE_MUN","CVE_LOC")){

        this.direction <- id.cols %>%
          keep_when(indicator == this.col.nom) %>%
          .$direction

        if(this.direction=="higher_positive"){

         scaled.this.col <- 1-scaled.this.col
        }


      }

      #scaling using caret package
      #process.num <- caret::preProcess(this.col, method=c("range"))
      #scaled.this.col <- stats::predict(process.num, this.col)

      list.cols[[eachcol]] <- scaled.this.col

    }

    scaled.vals <- list.cols %>%
      dplyr::bind_cols()

    list.ent[[eachstate]] <- scaled.vals
  }

  #keep only values for municipalities that only have one or two communities

  ent.sc.data <- list.ent %>%
    dplyr::bind_rows() %>%
    dplyr::left_join(cost.data.comms, by = c("CVE_MUN","CVE_LOC"))

   ent.sc.data.mun <- ent.sc.data %>%
    keep_when(CVE_MUN %in% single.mun.coms)


  return(ent.sc.data.mun)
}

  # scaled.vals <- scaled.cols %>%
  #   dplyr::bind_cols(loc.index) %>%
  #   dplyr::select(CVE_MUN, CVE_LOC, !!var, dplyr::everything())
  #
