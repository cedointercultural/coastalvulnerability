#' Scale variable
#'
#' @param datatable
#' @param sspscenario
#'
#' @return num.scale data with scaled total
#' @export
#'
#' @examples scaled.exp <- scale_var(this.data)
scale_var <- function(this.data, indicator.name){

  var <- dplyr::sym(paste0("tot_", indicator.name))

  loc.index <- this.data %>%
    select(CVE_MUN, CVE_LOC)

  loc.data <- this.data %>%
    select(-CVE_MUN, -CVE_LOC)

  max.col <- ncol(loc.data)

  cost.data.vals <- loc.data %>%
    replace(is.na(.), 0) %>%
    mutate(!!var := rowSums(dplyr::across(1:max.col), na.rm=TRUE))

  list.cols <- list()


  #skips code columns CVE_LOC & CVE_MUN
  for(eachcol in 1:ncol(cost.data.vals)){

    print(eachcol)
    this.col <- cost.data.vals %>%
      select({eachcol})

    scaled.this.col <- this.col %>%
      dplyr::mutate_if(is.numeric,~ scales::rescale(., to = c(0, 1)))

    #scaling using caret package
    #process.num <- caret::preProcess(this.col, method=c("range"))
    #scaled.this.col <- stats::predict(process.num, this.col)

    list.cols[[eachcol]] <- scaled.this.col

  }

  scaled.cols <- list.cols %>%
    dplyr::bind_cols()

  scaled.vals <- scaled.cols %>%
    dplyr::bind_cols(loc.index) %>%
    dplyr::select(CVE_MUN, CVE_LOC, !!var, dplyr::everything())

  return(scaled.vals)
}
